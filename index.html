<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="icon" href="favicon.svg">
<title>Recursion Schemes</title>
<link rel="stylesheet" href="assets/blog-cells.css" />
<script src="assets/babel.min.js"></script>
<script src="assets/blog-cells.js"></script>
<style>
main {
max-width: 40em;
margin: 0 auto 5em;
}

a {
	color: #1e70af;
}
</style>
</head>
<body>
<main>
<h1><img src="favicon.svg" alt="" style="height: 1em; vertical-align: text-bottom;"> Recursion Schemes</h1>

<p>
	This is a simple introduction to recursion schemes.
</p>

<p>
	Recursion schemes are a generalization of common patterns of recursion.
</p>

<p>
	If you have used <code>Array.map</code>, <code>Array.filter</code> or <code>Array.reduce</code> you are already familiar with higher order functions in which you only specify what to do to each element of an array but not how to iterate the array.
</p>

<p>
	TBD
</p>

<script type="text/javascript+notebook-cell" data-autorun="true">
export const someNumberArray = [1,2,3,4]
export const someBooleanArray = [true, false, false, true, true, false]
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">
function sumOfArrayRecursive(list) {
	if (list.length === 0) {
		return 0
	} else {
		return list[0] + sumOfArrayRecursive(list.slice(1))
	}
}

console.log(sumOfArrayRecursive(someNumberArray))
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">
function sumOfArrayRecursiveAccumulatedHelper(list, acc) {
	if (list.length === 0) {
		return acc
	} else {
		return sumOfArrayRecursiveAccumulatedHelper(list.slice(1), acc + list[0])
	}
}

function sumOfArrayTailRecursive(list) {
	return sumOfArrayRecursiveAccumulatedHelper(someNumberArray, 0)
}

console.log(sumOfArrayTailRecursive(someNumberArray))
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">

function sumOfArrayReduce(list) {
	const sum = (a,b) => a+b
	return list.reduce(sum, 0)
}

console.log(sumOfArrayReduce(someNumberArray))
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">


function fold(fn, init, list) {
	if (list.length === 0) {
		return init
	} else {
		return fn(list[0], fold(fn, init, list.slice(1)))
	}
}

function sumOfArrayReduce(list) {
	const sum = (a,b) => a+b
	return fold(sum, 0, list)
}

console.log(sumOfArrayReduce(someNumberArray))
</script>


<script type="text/javascript+notebook-cell" data-autorun="true">

function foldAccumulationHelper(fn, list, acc) {
	if (list.length === 0) {
		return acc
	} else {
		return foldAccumulationHelper(fn, list.slice(1), fn(acc, list[0]))
	}
}

export function fold(fn, init, list) {
	return foldAccumulationHelper(fn, list, init)
}

function sumOfArrayReduce(list) {
	const sum = (a,b) => a+b
	return fold(sum, 0, list)
}

console.log(sumOfArrayReduce(someNumberArray))
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">

function productOfArrayReduce(list) {
	const sum = (a,b) => a*b
	return fold(sum, 1, list)
}

console.log(productOfArrayReduce(someNumberArray))
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">

function maxOfArrayReduce(list) {
	const sum = (a,b) => Math.max(a,b)
	return fold(sum, -Infinity, list)
}

console.log(maxOfArrayReduce(someNumberArray))
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">

function minOfArrayReduce(list) {
	const sum = (a,b) => Math.min(a,b)
	return fold(sum, Infinity, list)
}

console.log(minOfArrayReduce(someNumberArray))
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">

function findOfArrayReduce(list, pred) {
	const sum = (a,b) => a !== null ? a : pred(b) ? b : null
	return fold(sum, null, list)
}

console.log(findOfArrayReduce(someNumberArray, (x) => x > 2))
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">

function anyOfArrayReduce(list) {
	const sum = (a,b) => a || b
	return fold(sum, false, list)
}

function allOfArrayReduce(list) {
	const sum = (a,b) => a && b
	return fold(sum, true, list)
}


console.log(anyOfArrayReduce(someBooleanArray))
console.log(allOfArrayReduce(someBooleanArray))
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">

function minOfArrayReduce(list) {
	const sum = (a,b) => Math.min(a,b)
	return fold(sum, Infinity, list)
}

console.log(minOfArrayReduce(someNumberArray))
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">

export function stringOfArrayReduce(list) {
	const sum = (a,b) => a ? `${a},${b}` : b
	return fold(sum, '', list)
}

console.log(stringOfArrayReduce(someNumberArray))
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">
export const someBinaryTree = {
	left: {
		left: {value: 3},
		right: {
			left: {value: 4},
			right: {value: 7}
		}
	}, 
	right: {
		left: {value: 2},
		right: {value: 6}
	}
}

export const someBooleanTree = {
	left: {
		left: {value: true},
		right: {
			left: {value: false},
			right: {value: true}
		}
	}, 
	right: {
		left: {value: true},
		right: {value: false}
	}
}
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">


export function foldTree(branchFn, leafFn, tree) {
	if (tree.hasOwnProperty("value")) {
		return leafFn(tree.value)
	} else {
		const leftFolded = foldTree(branchFn, leafFn, tree.left)
		const rightFolded = foldTree(branchFn, leafFn, tree.right)
		return branchFn(leftFolded, rightFolded)
	}
}

function sumOfTreeReduce(tree) {
	const leaf = (v) => v
	const combine = (a,b) => a + b
	return foldTree(combine, leaf, tree)
}

function stringSumOfTreeReduce(tree) {
	const leaf = (v) => `${v}`
	const combine = (a,b) => `${a} + ${b}`
	return foldTree(combine, leaf, tree)
}

console.log(stringSumOfTreeReduce(someBinaryTree) + " = " + sumOfTreeReduce(someBinaryTree))
</script>


<script type="text/javascript+notebook-cell" data-autorun="true">


function productOfTreeReduce(tree) {
	const leaf = (v) => v
	const combine = (a,b) => a*b
	return foldTree(combine, leaf, tree)
}

function minOfTreeReduce(tree) {
	const leaf = (v) => v
	const combine = (a,b) => Math.min(a,b)
	return foldTree(combine, leaf, tree)
}

export function stringOfTreeReduce(tree) {
	const leaf = (v) => v
	const combine = (a,b) => `<${a}:${b}>`
	return foldTree(combine, leaf, tree)
}


function maxOfTreeReduce(tree) {
	const leaf = (v) => v 
	const combine = (a,b) => Math.max(a,b)
	return foldTree(combine, leaf, tree)
}

function allOfTreeReduce(tree) {
	const leaf = (v) => v === true
	const combine = (a,b) => a && b
	return foldTree(combine, leaf, tree)
}

function anyOfTreeReduce(tree) {
	const leaf = (v) => v === true
	const combine = (a,b) => a || b
	return foldTree(combine, leaf, tree)
}

console.log(stringOfTreeReduce(someBinaryTree))

console.log(productOfTreeReduce(someBinaryTree))
console.log(minOfTreeReduce(someBinaryTree))
console.log(maxOfTreeReduce(someBinaryTree))
console.log(allOfTreeReduce(someBooleanTree))
console.log(anyOfTreeReduce(someBooleanTree))
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">
export const someLinkedList = {
	head: 5,
	tail: {
		head: 4, 
		tail: {
			head: 3, 
			tail: {
				head: 7, 
				tail: {
					head: 6, 
					tail: {nil: true}
				}
			}
		}
	}
}

export const someBooleanLinkedList = {
	head: true,
	tail: {
		head: false, 
		tail: {
			head: true, 
			tail: {
				head: true, 
				tail: {
					head: false, 
					tail: {nil: true}
				}
			}
		}
	}
}
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">


export function foldLinkedList(branchFn, init, linkedList) {
	if (linkedList.nil) {
		return init()
	} else {
		const rightFolded = foldLinkedList(branchFn, init, linkedList.tail)
		return branchFn(linkedList.head, rightFolded)
	}
}

function sumOfLinkedListReduce(linkedList) {
	const leaf = () => 0
	const combine = (a,b) => a + b
	return foldLinkedList(combine, leaf, linkedList)
}

function stringSumOfLinkedListReduce(linkedList) {
	const leaf = (v) => `0`
	const combine = (a,b) => `${a} + ${b}`
	return foldLinkedList(combine, leaf, linkedList)
}

export function stringOfLinkedListReduce(linkedList) {
	const leaf = (v) => `NIL`
	const combine = (a,b) => `${a} :: ${b}`
	return foldLinkedList(combine, leaf, linkedList)
}

console.log(stringOfLinkedListReduce(someLinkedList))

console.log(stringSumOfLinkedListReduce(someLinkedList) + " = " + sumOfLinkedListReduce(someLinkedList))
</script>



<script type="text/javascript+notebook-cell" data-autorun="true">
function mapArray(fn, array) {
	if(array.length === 0) {
		return []
	}
	return [fn(array[0]), ...mapArray(fn, array.slice(1))]
}

function mapTree(fn, tree) {
	if(tree.hasOwnProperty('value')) {
		return {value: fn(tree.value)}
	}
	return {
		left: mapTree(fn, tree.left),
		right: mapTree(fn, tree.right),
	}
}

function mapLinkedList(fn, list) {
	if(list.hasOwnProperty('nil')) {
		return list
	}
	return {
		head: fn(list.head),
		tail: mapLinkedList(fn, list.tail),
	}
}

const times3 = (x) => x*3

console.log(stringOfArrayReduce(someNumberArray))
console.log(stringOfTreeReduce(someBinaryTree))
console.log(stringOfLinkedListReduce(someLinkedList))

console.log(stringOfArrayReduce(mapArray(times3, someNumberArray)))
console.log(stringOfTreeReduce(mapTree(times3, someBinaryTree)))
console.log(stringOfLinkedListReduce(mapLinkedList(times3, someLinkedList)))
</script>



<script type="text/javascript+notebook-cell" data-autorun="true">


function mapPatternTree(fn, tree) {
	if(tree.hasOwnProperty('value')) {
		return tree
	}
	return {
		left: fn(tree.left),
		right: fn(tree.right),
	}
}

function mapPatternLinkedList(fn, list) {
	if(list.hasOwnProperty('nil')) {
		return list
	}
	return {
		head: list.head,
		tail: fn(list.tail),
	}
}

const sumPatternTree = (t) => {
	if(t.hasOwnProperty('value')) {
		return t.value
	} else {
		return t.left + t.right
	}
}

const sumPatternLinkedList = (l) => {
	if(l.hasOwnProperty('nil')) {
		return 0
	} else {
		return l.head + l.tail
	}
}

const rangeLinkedList = (l) => {
	if(l === 0) {
		return {nil: true}
	} else {
		return {head: l, tail: l-1}
	}
}

const cataMorphism = (algebra, mapper) => {
	const loop = (term) => {
		return algebra(mapper(loop, term))
	}
	return loop
}

const anaMorphism = (coalgebra, mapper) => {
	const loop = (seed) => {
		return mapper(loop, coalgebra(seed))
	}
	return loop
}

const hyloMorphism = (algebra, coalgebra, mapper) => {
	const loop = (seed) => {
		return algebra(mapper(loop, coalgebra(seed)))
	}
	return loop
}


console.log(cataMorphism(sumPatternLinkedList, mapPatternLinkedList)(someLinkedList))
console.log(stringOfLinkedListReduce(anaMorphism(rangeLinkedList, mapPatternLinkedList)(10)))
console.log(hyloMorphism(sumPatternLinkedList, rangeLinkedList, mapPatternLinkedList)(100))
</script>

<script type="text/javascript+notebook-cell" data-autorun="true">
const TreeF = Object.create({
  get isLeaf() {return this.type === 'Leaf'},
  get isNode() { return this.type === 'Node'},
  
  fmap (f) {
    if (this.isLeaf) {
      return TreeLeaf();
    } else if (this.isNode) {
      return TreeNode(this.value, f(this.left), f(this.right));
    }
  }, 

  toString() {
    return cata(treeConcatAlgebra)(this)
  }
})

const TreeLeaf = () => Object.create(TreeF, { type: {value: 'Leaf', writable: false} });
const TreeNode = (value, left = TreeLeaf(), right = TreeLeaf()) => Object.create(TreeF, { 
	type: {value: 'Node', writable: false},  
	value: {value: value, writable: false},  
	left: {value: left, writable: false}, 
	right: {value: right, writable: false} 
});


const ListF = Object.create({
  get isNil() {return this.type === 'Nil'},
  get isCons() { return this.type === 'Cons'},
      
  fmap (f) {
    if (this.isNil) {
      return ListNil;
    } else if (this.isCons) {
      return ListCons(this.value, f(this.tail));
    }
  },

  toString() {
    return cata(listConcatAlgebra)(this)
  }
})


const ListNil = Object.create(ListF, { type:  {value: 'Nil', writable: false} });
const ListCons = (value, tail) => Object.create(ListF, { type: {value: 'Cons', writable: false}, value:  {value, writable: false}, tail:  {value: tail, writable: false} });


const cata = (algebra) => {
  const go = (term) => algebra(term.fmap(go));
  return go;
};

const ana = (coalgebra) => {
  const go = (seed) => coalgebra(seed).fmap(go);
  return go;
};

const hylo = (algebra, coalgebra) => {
  const go = (seed) => algebra(coalgebra(seed).fmap(go));
  return go;
};

const para = (algebra) => {
  const go = (term) => algebra(term.fmap(sub => [go(sub), sub]));
  return go;
};

const apo = (coalgebra) => {
  // Note: apo needs a convention like { isFix: true, value: term } to mark early-exits.
  const go = (seed) => {
    const layer = coalgebra(seed);
    return layer.fmap(e => e instanceof Object && e.isFix ? e.value : go(e));
  };
  return (seed) => ({ isFix: true, value: go(seed) }); // mimic Fix without wrapper
};

const zygo = (f, g) => {
  const go = (term) => {
    const pair = term.fmap(go);
    const b = g(pair.map(([_, b]) => b));
    const a = f(pair.map(([a, _]) => a), b);
    return [a, b];
  };
  return (term) => go(term)[0];
};

const chrono = (f, g) => {
  const go = (seed) => {
    const layer = g(seed); // coalgebra: g :: a -> F (a, b)
    const mapped = layer.fmap(([a, b]) => {
      const [v, memo] = go(a);
      return [v, b]; // use memo
    });
    const value = f(mapped);
    return [value, null]; // ignore second if needed
  };
  return (seed) => go(seed)[0];
};

const histo = (algebra) => {
  const go = (term) => {
    const cache = term.fmap(go);
    const result = algebra(cache);
    return { result, cache }; // tie the knot
  };
  return (term) => go(term).result;
};

const futu = (coalgebra) => {
  const go = (seed) => {
    const layer = coalgebra(seed);
    return layer.fmap(go);
  };
  return go;
};

const treeSumAlgebra = (node) => {
  if (node.isLeaf) {
    return 0;
  } else if (node.isNode) {
    return  node.value + node.left + node.right;
  }
};

const treeConcatAlgebra = (node) => {
  if (node.isLeaf) {
    return '*';
  } else if (node.isNode) {
    return "("+node.left + " < " + node.value.toString()  + " > "  + node.right+")";
  }
};


const listSumAlgebra = (node) => {
  if (node.isCons) {
    return node.value + node.tail
  } else if (node.isNil) {
    return 0
  }
};

const listConcatAlgebra = (node) => {
  if (node.isCons) {
    return node.value + " :: " +  node.tail
  } else if (node.isNil) {
    return "NIL"
  }
};


const treeMaxAlgebra = (init = -Infinity) =>  (node) => {
  if (node.isLeaf) {
    return init;
  } else if (node.isNode) {
    return Math.max(node.value, node.left, node.right);
  } 
};

const listMaxAlgebra = (init = -Infinity) => (node) => {
  if (node.isCons) {
    return Math.max(node.value, node.tail)
  } else if (node.isNil) {
    return init
  }
};

const myListCoAlgebra = (x) => {
  return x > 0 ? ListCons(x, x-1) : ListNil
}

const myTreeCoAlgebra =  (x) => {
  return x > 0 ? TreeNode(x, x-1, x-1) : TreeLeaf()
}

const listMapAlgebra = (f) => (node) => {
  if (node.isNil) return ListNil;
  if (node.isCons) return ListCons(f(node.value), node.tail);
}

const treeMapAlgebra = (f) => (node) => {
  if (node.isLeaf) {
    return TreeLeaf();
  } else if (node.isNode) {
    return TreeNode(f(node.value), node.left, node.right)
  }
}

const annotateListLength = (node) => {
  if (node.isNil) {
    return ListNil;
  }

  const head = node.value;
  const [recurResult, originalTail] = node.tail;
  
  const len = recurResult.isCons
    ? recurResult.value[1] + 1
    : 1;

  return ListCons([head, len], recurResult);
};

const reverseListAlgebra = (node) =>
  node.isNil
    ? (acc) => acc
    : (acc) => node.tail(ListCons(node.value, acc));

function getArrowFunctionBody(f) {
	const matches = f.toString().match(/^(?:\s*\(?(?:\s*\w*\s*,?\s*)*\)?\s*?=>\s*){?([\s\S]*)}?$/);
	if (!matches) {
	return null;
	}

	const firstPass = matches[1];

	// Needed because the RegExp doesn't handle the last '}'.
	const secondPass =
	(firstPass.match(/{/g) || []).length === (firstPass.match(/}/g) || []).length - 1 ?
	  firstPass.slice(0, firstPass.lastIndexOf('}')) :
	  firstPass

	return secondPass;
}
	
const l = ListCons(8, ListCons(3, ListCons(7, ListNil)))
const t = TreeNode(0, TreeNode(0, TreeNode(3), TreeNode(4)), TreeNode(10, TreeNode(2), TreeNode(1)))
const examples = [
	() => (l.toString()),
	() => (t.toString()),
	
	() => (cata(reverseListAlgebra)(l)(ListNil)),
	 
	() => (cata(listSumAlgebra)(l)),
	() => (cata(treeSumAlgebra)(t)),
	() => (cata(listMaxAlgebra())(l)),
	() => (cata(treeMaxAlgebra())(t)),
	
	() => (ana(myListCoAlgebra)(10).toString()),
	() => (ana(myTreeCoAlgebra)(3).toString()),
	
	() => (hylo(listSumAlgebra, myListCoAlgebra)(10)),
		
	() => (hylo(
		(node) => node.isNil ? 0 : node.value + node.tail, 
		(x) => x < 1 ? ListNil : ListCons(x, x-1)
	)(100)),
	
	() => (cata(listMapAlgebra(x => x * 2))(l).toString()),
	() => (cata(treeMapAlgebra(x => x * 1))(t).toString()),
	() => (cata(treeMapAlgebra(x => x * 2))(t).toString()),
	
	() => (para(annotateListLength)(l).toString()),
	
	() => (listMapAlgebra(([a,b]) => a*b)(para(annotateListLength)(l)).toString()),
]

for(let e of examples) {
	console.log(getArrowFunctionBody(e).trim(), e())
}
</script>

<h2>References</h2>


<p>
	TBD
</p>

</main>
</body>
</html>